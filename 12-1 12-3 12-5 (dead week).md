#### HW Hint 10:

1. Know how to code TM
2. Know how to code TM
3. Write reasoning clearly by simulation 1-turn using a stack (push's and pop's)
4. TM tape === two stacks

---

#### HW Hint 11:

1. ... 
	1. Show that if both L and L' are r.e., then L is recursive. Proof: Since L is r.e., we have a TM M to accept it. That is, for all x in L, M says yes on x. For all x not in L, M doesn't say yes on x. Since L' is r.e., we have a TM M' to accept it. [repeat definition like for L but for L']. Remark: if x in L iff x not in L. And x not in L' iff x in L. To show that L is recursive, we need to construct an alg M hat to recognize L : input x; Run M and M' on x *in parallel*. If M says yes on x, return yes. If M' says yes on x, return no.
	2. Show that r.e. languages are not closed under compliment (there is a lang. L s.t. L is r.e. but L' is not r.e.). Many ways. We proved L = L_self is r.e. but L_notself is not r.e.
2. Show that recursive languages are closed under compliment. Proof: we need to show that if L is recursive, then so it L'. By definition, L is recursive then there is an alg M to recognize L (for all x, x in L, M says yes; for all x, x not in L, M says no). To show L' is recursive, we construct alg M' to construct L'. NOTE: M' can only be constructed from M. M': input x; Run M on x; if M says yes on x, return no; if M says no on x, return yes (since M WILL halt).
3. There are infinitely many i s.t. L(M) = L(M_i). Add "garbage" instructions to M so that those instructions will never run and hence they will accept the same language L(M).
4. Alg : inspect the code of the TM and make sure\# of L-inst = \# of R-inst. Don't run the TM
5. you can add garbage instructions to make sure \# of L-inst = \# of R-inst.

---

#### Final Review:

Final: 12/10, Wednesday, 7:30-9:30pm in classroom

Things to do to prepare:
- 2-page cheating sheet
- Re-do standard problems in HW
- do all the problems in Review Sessions while watching the recording

Final covers everything *after* midterm

Know how to:
- C.F. Grammar
- PDA
- TMs
- Pumping Lemma for reg. langs
- Pumping Lemma for c.f. langs

B1: Given a CF Grammar, describe the language generated by the grammar.
- Example: 
	- S --> 0S1 | 01
	- lang = {0^n 1^n : n >= 1}
	- Pay attention to the base condition(s)!!!!!
- Example:
	- S --> AB
	- A --> 0A | 00
	- B --> B1| 1
	- lang = {0^n 1^m : n >= 2, m >= 1}
- Example:
	- S --> 0ASA0 | ^
	- A --> 1A | 1
	- describe S: 0A 0A ... A0 A0 means a \# of 0A-A0 pairs.
	- describe A: 1+
	- describe: 01+ 01+ ... 1+0 1+0 with even \# of 0's

B2: Given a language, write a grammar.
- Example:
	- l = {1^n 0^m 1^3m 0^2n : m >= 0, n >=1}
	- Write grammar: (remember: outside to inside, and take care of base case last)
	- S --> 1S00 | A | 100
	- A ---> 0A111 | ^

B3: Eliminate $\Lambda$  and $\cup$ productions, and create CNF.
- Example:
	- Grammar:
		- S --> aSb | ab
	- Convert to CNF:
		- S --> AC | AB
		- A --> a
		- B --> b
		- C --> SB

B4: PDA - Given a language, describe in English a PDA to accept it. (remember: PDA is non-det, so it can guess)
- Example:
	- Accept {xx^r : x {a, b}\*}
	- Suppose x = abb. w = [abbbba]
	- On an input word w, M works as follows. It pushes each symbol read onto the stack. Moments later, M guesses now it is in the middle of the input. Then, it switches the mode. now for each symbol read, it pops the stack and compares with the symbol read (making sure that they both match). At the end of input, if the stack is empty, M says yes on w. Clearly, M is a PDA which accepts the language.
- DO Example:
	- Accept {w : w = w^r, w in {0, 1}\*}
	- ...
- Example:
	- Accept {0^2n 1^3n : n >= 0}
	- (run a small example with PDA and stack)
	- read two 0's and push 3 1's
	- ...
- DO Example:
	- Accept {0^2n 1^m 0^3m 1^4n : m >= 0, n>= 1}
	- ...

More PDA things to know how to do:
- Explicit PDA construction (with delta)
- Grammar to PDA

B5: Use PL to prove a language is not regular, and prove a language is not c.f.
- Example:
	- Show that L = {a^n b^n : n >= 0} is NOT regular
	- Show that L = {a^n B^n c^n : n >= 0} is NOT C.F.
	- Check lecture notes and make stupid mistakes on basic simple problems

Must know basic definitions of:
- r.e.
- recursive
- decidable
- undecidable

Ex's:
- If L_1 is recursive, L_2 is recursive, then so is L_1 intersects L_2
	- Since L_1 is recursive [rep. def.] And since L_2 is recursive [rep. def.]. [proof like on hw 11]. Since both M_1 and M_2 are algs, the two runs will halt. Then combine results.
- If L_1 and L_2 are r.e., then so is L_1 union L_2
	- [rep. def.] for L_1 and L_2. 

How to prove that a problem is decidable: Show that there is an alg to solve the problem.