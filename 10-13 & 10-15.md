Homework hint (key):
1. Define End(L,a) = { w in L s.t. w ends with a}. We know End(L,a) is regular since L is regular. There is a word ended with a in L iff End(L,a) != !0. Algorithm for emptiness.
2. [ON EXAM] Given M1 and M2 FA's... **"Whenever you're looking for if there is a word, you look for emptiness"** We define a set called [Fancy L] = all words x satisfy either case (in M1 not M2, or in M2 not M1).
	1. L = {x in L(M1) and x !in L(M2)} and {x in L(M2) and x !in L(M1)}
	2. We need only show there is an alg to decide whether L = empty?
	3. Exam full of those kinds of problems
	4. Prove L is regular, done
	5. Notice L = (x in L(M1) and x in L(M2) compliment) intersect (x in L(M2) and x in L(M1) compliment)
	6. Show reg intersect reg still reg, along with union (closed under all boolean operations including intersection, union, and compliment)
3. automata-to-automata; ~~reverse~~ flip (read) transitions in FA. e.x. (abc)\* to (cba)\*.
4. [ON EXAM] Define Prefix(L) = {w : Exist(w'), ww' in L}. Show Prefix(L) is regular if L is regular. Use Automata-to-automata construction. Exists y : xy in L. You're looking for the Y
	1. GENERAL NOTES:
		1. Given reg
		2. Show new lang is also reg based on old reg
		3. find a way to construct new based on old by working from new to old
		4. new: suppose word = x
		5. old: has to include x, need additional word appended to make a word in L
		6. Then do proof based on above logic
		7. Write diagram
		8. NFA, take guess, always right. M' run on x simulating M reading x. M' guesses symbol by symbol after x to build y (ghost), which makes M accept xy.
	2. WHOLE LOGIC:
		1. Proof:
		2. Let FA M accept reg. lang. L. We will construct another FA M' to accept Prefix(L).
		3. M' runs on input x at follows:
		4. For each symbol M' reads, it simulates M running on the same symbol. At the end of x, M' guesses symbol by symbol a word y and let M run on the guessed y. M' says yes on x iff M says yes on xy. Clearly, M' accepts Prefix(L).
5. automata-to-automata; 
	1. Right side:
		1. Draw M' accepting Half(L), reading x
		2. M' says yes on x
	2. Left side:
		1. Draw M accepting L = {x : xy in L and |x|=|y|}
		2. To make sure length of strings are equal: stack x on y and have two copies of M
		3. To keep length comparison but also make sure M accepts xy, start M running on Y on a guessed state, which M running on X will end on
	3. Proof :
		1. We will construct a FA M' to accept Half(L). M' runs on input x as follows: On reading x, $M'$ simulates to copies of $M$, $M_1$ and $M_2$ in parallel. First copy, $M_1$, runs on x. Second copy, $M_2$, runs on a guessed y. In particular, $M_2$ starts with a guessed state `BadApple`. At the end of x, $M'$ says yes on x if $M_1$ ends up with state `BadApple` and $M_2$ ends up with accepting state. Clearly, L(M') = Half(L).
		2. (Note: should be 'iff', but no one ever writes that and only 'if').

[FINAL EXAM PROBLEM]
- Third(L) = { x : exist(y). xy in L and |x| = 2|y| }
- Ex: xy: [aaba][bb]
- Stack x on top of x on top of y; $x_1$, $x_2$, $y$

Give alg to solve {2x - 3y = 6; x + 4y -7z = 13} in x, y, z in Natural Numbers
Give solution to 2x-3y=17
ILP: Integer Linear Programming
Build a graph, depth-first-search from starting node to double-circle node on graph to see if you have a valid walk. If so, there is a solution
Graduate level algorithm design: solve problem by not looking at the problem. Instead, solve a graph problem of that
