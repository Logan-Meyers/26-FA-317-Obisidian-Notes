## HW Hint:
- 1-5 OK
- 6:
	- ex: 0001
	- S -> 00S1 | A
	- A -> 0A | 0
- 7:
	- ex: 001111
	- S -> 0S11 | A | 0A1
	- A -> A1 | 1
- 8:
	- n != 2m, use 6 & 7
	- n > 2m OR n < 2m (language union)
- 9-11: just follow class notes
	- 9. figure out which symbols go to lambda, follow class notes from there

#### Grammar $\rightarrow$ machine construction (PDA)

Example grammar:
- S -> 0S1 | 01

Example Stack:
1. Push start symbol onto stack: S
2. 1S0 (pop S, replace with 0S1 by pushing from back)
3. 11S00 (pop 0 until S, push 0S1 by pushing from back, add back in 0's)
4. When 1 read, 1 popped from stack
5. If z_0 at end, says yes

PDA:
- delta(q_0, lambda, z_0) = {(q, Sz_0)}
- delta(q, lambda, z_0) = {(q_1, z_0)}  // accepting
- delta(q, \*, \*) = {(q, lambda)}  // \* in {0, 1}
- delta(q, lambda, S) = {(q, 0S1), (q, 01)}  // S -> 0S1 | 01
In summary (alg for grammar to machine construction):
- delta(q_0, lambda, z_0) = {(q,Sz_0)}  // push start symbol to stack
- delta(q, lambda, z_0) = {(q_1, z_0)}  // q_1 is accepting
- delta(q, a, a) = {(q, lambda)}  // a in sigma, pop from stack if symbol and top of stack matches
- delta(q, lambda, A) = {(q, a)}  // A -> a is a grammar rule

#### Machine Construction $\rightarrow$ C.F. Grammar

L(M) = L(G)

Assumption: Assume that the PDA M, when accepts at the end of input, pops everything from out of the stack, including the z_0.

Intuition:
- Stack[z_0] → Stack[z_0 ...] → Stack[ ]
- PDA M at state p: Stack[z_0 ... A]
- Word y' read to get from p to q
	- the 'price' we pay to pop the A out.
	- Written $[p, A, q] \Rightarrow^*_G y'$.
	- Portion $[p, A, q]$ is treated as a nonterminal symbol in the grammar that we are constructing
- PDA M at state q: Stack[z_0 ...] (A from above is popped off)
- PDA M at end of input: Stack[ ]

[FINAL EXAM] Algorithm (machine to grammar):
- [pop]: delta(p, a, A) <-in (q, lambda)  // (q, lambda) in delta(p, a, A) means pop A safely while reading input symbol a and moving from p to q. [p, A, q] → a
- [push]: delta(p, a, A) <-in (p_1, gamma) with gamma != lambda
	- Let gamma = B_1 ... B_m
	- State p, read a, top of stack is A. move to state p_1. replace stack's A → B_1 ... B_m (B_1 at top of stack)
	- moving to next state q, all of top of stack is popped off, so that all of the stack is still there up to where A was previously
	- price paid to pop A: word from p to q, including p_1 and everything in between
	- [p, A, q] → a[p_1, B_1, p_2][p_2, B_2, p_3] ... [p_m, B_m, p_m+1] where p_m+1 = q and gamma = B_1 ... B_m
- [initial rule] S → [q_0, z_0, q]

Example:
- Given PDA:
	- Q = {q_0, q_1, q_2}
	- sigma = {0, 1)
	- Gamma = {0, 1, z_0}
	- A = {q_2}
	- delta(z_0, 0, z_0) = {(z_0, 0z_0)}
	- delta(q_0, 0, 0) = {(q_0, 00)}
	- delta(q_0, 1, 0) = {(q_1, lambda)}
	- delta(q_1, 1, 0) = {(q_1, lambda)}
	- delta(q_1, lambda, z_0) = {(q_2, lambda)}  // empty stack acceptance
- Translation steps to C.F. Grammar:
	- For delta(q_0, 1, 0) = {(q_1, lambda)}, $[q_0, 0, q_1] \rightarrow 1$
	- For delta(q_1, 1, 0) = {(q_1, lambda)}, [q_1, 0, q_1] → 1
	- For delta(q_1, lambda, z_0) = {(q_2, lambda)}, [q_1, z_0, q_2] → lambda
	- For delta(q_0, 0, 0) = {(q_0, 00)}, [q_0, z_0, \*_1] → 0[q_0, 0, \*_2][*_2, z_0, *_1] where \*1 \*2 in Q. This line corresponds to 9 rules
	- For delta(q_0, 0, 0) = {(q_0, 00)}, $[q_0, 0, *_1] \rightarrow 0[q_0, 0, *_2][*_2, 0, *_1]$ where $*_1, *_2 \in Q$*
	- Additional rule: $S \rightarrow [q_0, z_0, *_1]$

Regular Languages $\in$ C.F. Langauges $\in$ All Languages
We have languages which are not regular but are context-free

We will prove a language is not context-free:

**Pumping Lemma for C.F. Languages:**
1. Let L be an infinite c.f. language
2. Then there is a number n s.t. for each word $z$ in L with $|z| \ge n$, z can be written into 5 parts: $z = uvwxy$
3. $z = uvwxy$ s.t.
	1. |vwx| $\le n$
	2. |vx| $\ge 1$
	3. for all i, $uv^iwx^i \in L$

Example proof: show $L = \{a^n b^n c^n: n \ge 0\}$ is not c.f.:
Proof (use P.L.):
- Assume L is c.f.
- According to the PL, let n be the number stated in the lemma. 
- Pick a z = $a^nb^nc^n$, where n is in pumping lemma, with $|z| = 3n \ge n \in L$
- For each possible way to write the z into 5 parts: $z = uvwxy$ s.t.
	- $|vwx| \le n, |vx| \ge 1$,
	- `z = | a ... a | b ... b | c ... c |`
	- `.....<-- n --> <-- n --> <-- n -->`
	- and:
	- `z = | u | v | w | x | y |`
	- `.........<-  <= n ->`
	- The middle combined, vwx, can contain at most two kinds of symbols.
	- Therefore, since |vx| <= 1, we take i=2: uvvwxxy $\notin$ L
	- This causes an off-balance

Remark: Take 10% in [FINAL]: PL for CF Languages

Closure properties of CF Languages:
- $L_1 \cup L_2$ - Union.

Non closure of CF Languages:
- $L_1 \cap L_2$ - Intersection (due to complexity)
- $\overline{L}$ - Complement (due to needing intersection to work)

Union example:
- $S \rightarrow 0s1|\Lambda$
- $S \rightarrow AS1 | a$ & $A \rightarrow a$
- $L_1 \cup L_2$:
	- $S \rightarrow S_1 | S_2$
	- $S_1 \rightarrow 0S_11 | \Lambda$
	- $S_2 \rightarrow 0A1 | a$
	- $A \rightarrow a$

Membership: word $w \in L$ ?
- input w
- convert PDA M into grammar G
- See if G can generate w by analyzing the grammar tree

Emptiness: Given a PDA M, whether $L(M) = \emptyset$ ?
- input PDA M
- convert PDA M into grammar G (machine $\rightarrow$ grammar construction)
- see if $S \in G$ can generate any terminal word by inspecting grammar tree
- If yes, $L \ne \emptyset$
- If no, $L = \emptyset$

Example: C program P with only boolean variables and function calls (call stack!). We find an algorithm to decide if P halts.
- clearly, P is a PDA. Because boolean variables can be encoded into finite memory of the PDA, and it uses a call stack which can be simulated by the stack in the PDA
- "p halts" $\Rightarrow$ emptiness of PDA that simulated P

**|int x| = word**